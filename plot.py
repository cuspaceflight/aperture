from components import *
from math import pi
import em_calcs as em

# takes array of points and formats them into a KiCAD PCB file
def generate_file(spec, points, destination):
    template = open("pcb_template.kicad_pcb", "r").read()

    furthest_point = 0
    for p in points:
        if p[1] < furthest_point:
            furthest_point = round(p[1],1)

    circumference = round(float(spec["body_radius"])*2*pi, 1)

    sheet_top_left = [-circumference/2, furthest_point-20]
    sheet_bottom_right = [circumference/2, 20]

    print("Sheet size [width, height]: ", [sheet_bottom_right[0] - sheet_top_left[0], sheet_bottom_right[1] - sheet_top_left[1]])

    antenna_string = "  (gr_poly\n    (pts\n"

    centre_offset = [210, 200] # move shape to center of page, arbitrary

    sheet_top_left[0] += centre_offset[0]
    sheet_top_left[1] += centre_offset[1]
    sheet_bottom_right[0] += centre_offset[0]
    sheet_bottom_right[1] += centre_offset[1]

    for p in points:
        antenna_string += "      (xy " + str(p[0]+centre_offset[0]) + " " + str(p[1]+centre_offset[1]) + ")\n"
    
    antenna_string += "    )\n  (layer \"F.Cu\") (width 0) (fill solid))"

    antenna_string += "(gr_rect (start "+str(sheet_top_left[0])+" "+str(sheet_top_left[1])+") (end "+str(sheet_bottom_right[0])+" "+str(sheet_bottom_right[1])+") (layer \"Edge.Cuts\") (width 0) (fill none))"

    template = template.replace("contentscontents", antenna_string)

    title_block = "(title_block\n    (title \"antenna\")\n    (comment 1 \"Generated by Aperture.py by Daniel Fearn\")\n    (comment 2 \"github.com/cusf/aperture\")\n  )"

    template = template.replace("titleblocktitleblock", title_block)

    open(destination, "w").write(template)

# helper function to generate DXF code for a line given two points
def dxf_line(x1, y1, x2, y2):
    return "\n  0\nLINE\n  8\nTOP\n  6\nCONTINUOUS\n  10\n"+str(x1)+"\n  20\n"+str(y1)+"\n  11\n"+str(x2)+"\n  21\n"+str(y2)

# takes array of points and formats them into a DXF file
def generate_dxf(spec, points, destination):
    headers = "  0\nSECTION\n  2\nHEADER\n  0\nENDSEC\n  0\nSECTION\n  2\nTABLES\n  0\nTABLE\n  2\nLAYER\n  70\n1\n  0\nLAYER\n  2\nTOP\n  70\n0\n  62\n7\n  6\nCONTINUOUS\n  0\nENDTAB\n  0\nENDSEC\n  0\nSECTION\n  2\nENTITIES"
    contents = ""

    for i in range(len(points)-1):
        contents += dxf_line(points[i][0], -points[i][1], points[i+1][0], -points[i+1][1])
        pass
    
    contents += dxf_line(points[i+1][0], -points[i+1][1], points[0][0], -points[0][1])
    open(destination, "w").write(headers + contents + "\n  0\nENDSEC\n  0\nEOF")

# generates recursive tree of microstrip components based on specification
def construct_array(spec):
    tube_circumference = spec["body_radius"]*2*pi
    spacing = tube_circumference/8

    if spec["polarisation"] == "axial":
        patch1 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
        patch2 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
        patch3 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
        patch4 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
    else:
        patch_impedance = em.microstrip_patch_impedance(spec, em.square_patch(spec)[0])
        patch1  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
        patch2  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
        patch3  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
        patch4  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
    
    if spec["patch_count"] == 2:
        branch1 = patch1
        branch2 = patch2
    elif spec["patch_count"] == 4:
        benda = MitredBendAtPoint(spec, 50, -3*spacing, 10, Dir.RIGHT, [patch1])
        bendb = MitredBendAtPoint(spec, 50, -spacing, 10, Dir.LEFT, [patch2])
        bendc = MitredBendAtPoint(spec, 50, spacing, 10, Dir.RIGHT, [patch3])
        bendd = MitredBendAtPoint(spec, 50, 3*spacing, 10, Dir.LEFT, [patch4])
        branch1 = PowerSplitter2_linefeed(spec, 50, 50, [], [bendb, benda])
        branch2 = PowerSplitter2_linefeed(spec, 50, 50, [], [bendd, bendc])
    else:
        return patch1 # return only a single patch with its feed, useful for validation testing


    bend1 = MitredBendAtPoint(spec, 50, -2*spacing, 10, Dir.RIGHT, [branch1])
    bend2 = MitredBendAtPoint(spec, 50, 2*spacing, 10, Dir.LEFT, [branch2])
    return PowerSplitter2_pinfeed(spec, 50, 50, 0.3, [], [bend2, bend1])