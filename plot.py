from components import *
from math import pi
import em_calcs as em

# takes a tree of components and formats their plot into a KiCAD PCB file
def generate_file(spec, tree, destination):
    template = open("pcb_template.kicad_pcb", "r").read()

    points = tree.plot([0, 0])

    furthest_point = 0
    for p in points:
        if p[1] < furthest_point:
            furthest_point = round(p[1],1)

    circumference = round(float(spec["body_radius"])*2*pi, 1)

    sheet_top_left = [-circumference/2, furthest_point-20]
    sheet_bottom_right = [circumference/2, 20]

    print("Sheet size [width, height]: ", [sheet_bottom_right[0] - sheet_top_left[0], sheet_bottom_right[1] - sheet_top_left[1]])

    antenna_string = "  (gr_poly\n    (pts\n"

    centre_offset = [210, 200] # move shape to center of page, arbitrary

    sheet_top_left[0] += centre_offset[0]
    sheet_top_left[1] += centre_offset[1]
    sheet_bottom_right[0] += centre_offset[0]
    sheet_bottom_right[1] += centre_offset[1]

    for p in points:
        antenna_string += "      (xy " + str(p[0]+centre_offset[0]) + " " + str(p[1]+centre_offset[1]) + ")\n"
    
    antenna_string += "    )\n  (layer \"F.Cu\") (width 0) (fill solid))"

    antenna_string += "(gr_rect (start "+str(sheet_top_left[0])+" "+str(sheet_top_left[1])+") (end "+str(sheet_bottom_right[0])+" "+str(sheet_bottom_right[1])+") (layer \"Edge.Cuts\") (width 0) (fill none))"

    template = template.replace("contentscontents", antenna_string)

    title_block = "(title_block\n    (title \"antenna\")\n    (comment 1 \"Generated by Aperture.py by Daniel Fearn\")\n    (comment 2 \"github.com/cusf/aperture\")\n  )"

    template = template.replace("titleblocktitleblock", title_block)

    open(destination, "w").write(template)


def construct_array(spec):
    tube_circumference = spec["body_radius"]*2*pi
    spacing = tube_circumference/8

    if spec["polarisation"] == "axial":
        patch1 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
        patch2 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
        patch3 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
        patch4 = InsetFeed(spec, 50, Dir.UP, [LinearPatch(spec, Dir.UP, [])])
    else:
        patch_impedance = em.microstrip_patch_impedance(spec, em.square_patch(spec)[0])
        patch1  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
        patch2  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
        patch3  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
        patch4  = MatchLine(spec, 50, patch_impedance, Dir.UP, [SquarePatch(spec, Dir.UP, [])])
    
    if spec["patch_count"] == 2:
        branch1 = patch1
        branch2 = patch2
    elif spec["patch_count"] == 4:
        benda = MitredBendAtPoint(spec, 50, -3*spacing, 10, Dir.RIGHT, [patch1])
        bendb = MitredBendAtPoint(spec, 50, -spacing, 10, Dir.LEFT, [patch2])
        bendc = MitredBendAtPoint(spec, 50, spacing, 10, Dir.RIGHT, [patch3])
        bendd = MitredBendAtPoint(spec, 50, 3*spacing, 10, Dir.LEFT, [patch4])
        branch1 = PowerSplitter2_linefeed(spec, 50, 50, [], [bendb, benda])
        branch2 = PowerSplitter2_linefeed(spec, 50, 50, [], [bendd, bendc])


    bend1 = MitredBendAtPoint(spec, 50, -2*spacing, 10, Dir.RIGHT, [branch1])
    bend2 = MitredBendAtPoint(spec, 50, 2*spacing, 10, Dir.LEFT, [branch2])
    return PowerSplitter2_pinfeed(spec, 50, 50, 0.3, [], [bend2, bend1])