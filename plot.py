from components import *
from math import pi
import em_calcs as em

# takes a tree of components and formats their plot into a KiCAD PCB file
def generate_file(spec, tree, destination):
    template = open("pcb_template.kicad_pcb", "r").read()

    points = tree.plot([0, 0])

    furthest_point = 0
    for p in points:
        if p[1] < furthest_point:
            furthest_point = p[1]

    sheet_top_left = [-float(spec["body_radius"])*pi, furthest_point-20]
    sheet_bottom_right = [float(spec["body_radius"])*pi, 20]

    antenna_string = "  (gr_poly\n    (pts\n"

    centre_offset = [210, 200] # move shape to center of page, arbitrary

    sheet_top_left[0] += centre_offset[0]
    sheet_top_left[1] += centre_offset[1]
    sheet_bottom_right[0] += centre_offset[0]
    sheet_bottom_right[1] += centre_offset[1]

    for p in points:
        antenna_string += "      (xy " + str(p[0]+centre_offset[0]) + " " + str(p[1]+centre_offset[1]) + ")\n"
    
    antenna_string += "    )\n  (layer \"F.Cu\") (width 0) (fill solid))"

    antenna_string += "(gr_rect (start "+str(sheet_top_left[0])+" "+str(sheet_top_left[1])+") (end "+str(sheet_bottom_right[0])+" "+str(sheet_bottom_right[1])+") (layer \"Edge.Cuts\") (width 0) (fill none))"

    template = template.replace("contentscontents", antenna_string)

    title_block = "(title_block\n    (title \"antenna\")\n    (comment 1 \"Generated by Aperture.py by Daniel Fearn\")\n    (comment 2 \"github.com/cusf/aperture\")\n  )"

    template = template.replace("titleblocktitleblock", title_block)

    open(destination, "w").write(template)

def construct_array_4axial(spec):
    tube_circumference = spec["body_radius"]*2*pi
    spacing = tube_circumference/8

    patch_impedance = em.microstrip_patch_impedance(spec, em.microstrip_patch(spec)[0])

    patch1 = LinearPatch(spec, Dir.UP, [])
    patch2 = LinearPatch(spec, Dir.UP, [])

    match1 = MatchLine(spec, 50, patch_impedance, Dir.UP, [patch1])
    match2 = MatchLine(spec, 50, patch_impedance, Dir.UP, [patch2])

    bend2aa = MitredBendAtPoint(spec, 50,  3*spacing, 10, Dir.LEFT, [match1])
    bend2ab = MitredBendAtPoint(spec, 50,  spacing, 10, Dir.RIGHT, [match2])
    splitter2a = PowerSplitter2_linefeed(spec, 50, 50, [], [bend2aa, bend2ab])
    bend1 = MitredBendAtPoint(spec, 50, 2*spacing, 10, Dir.LEFT, [splitter2a])

    patch3 = LinearPatch(spec, Dir.UP, [])
    patch4 = LinearPatch(spec, Dir.UP, [])

    match3 = MatchLine(spec, 50, patch_impedance, Dir.UP, [patch3])
    match4 = MatchLine(spec, 50, patch_impedance, Dir.UP, [patch4])


    bend2bb = MitredBendAtPoint(spec, 50,  -spacing, 10, Dir.LEFT, [match3])
    bend2ba = MitredBendAtPoint(spec, 50,  -3*spacing, 10, Dir.RIGHT, [match4])
    splitter2b = PowerSplitter2_linefeed(spec, 50, 50, [], [bend2bb, bend2ba])
    bend2 = MitredBendAtPoint(spec, 50, -2*spacing, 10, Dir.RIGHT, [splitter2b])

    splitter1 = PowerSplitter2_pinfeed(spec, 50, 50, 0.3, [], [bend1, bend2])

    return splitter1

def construct_array_2axial(spec):
    tube_circumference = spec["body_radius"]*2*pi
    spacing = tube_circumference/8

    patch_impedance = em.microstrip_patch_impedance(spec, em.microstrip_patch(spec)[0])

    patch1 = LinearPatch(spec, Dir.UP, [])
    patch2 = LinearPatch(spec, Dir.UP, [])

    match1 = MatchLine(spec, 50, patch_impedance, Dir.UP, [patch1])
    match2 = MatchLine(spec, 50, patch_impedance, Dir.UP, [patch2])

    bend1 = MitredBendAtPoint(spec, 50, 2*spacing, 10, Dir.LEFT, [match1])
    bend2 = MitredBendAtPoint(spec, 50, -2*spacing, 10, Dir.RIGHT, [match2])

    splitter1 = PowerSplitter2_pinfeed(spec, 50, 50, 0.3, [], [bend1, bend2])

    return splitter1